code .

# 파이썬 pep8

1. 프로그래밍이 무엇인지 이해하고 설명할 수 있다.

2. Python의 특징과 장점을 이해하고, 코드를 실행할 수 있다.

3. 표현식,값,문장의 개념을 구분하여 설명할 수 있다.

4. 변수를 활용하여 값을 저장하고, 메모리 구조를 이해한다.

5. 숫자,문자열 등 기본 데이터 타입을 구분하고 활용할 수 있다.


**핵심키워드 정리**
1.표현식(Expression) : 값을 만들어내는 코드 조각 ex) 3+5, "hello", 2*a
2.값(Value) : 표현식이 만들어내는 결과물 ex) 8, "hello", True
3.문장(Statement) : 실행 가능한 코드 한 줄 ex) print("hello"), a = 3
4.변수(Variable) : 값을 저장하는 이름표 (메모리 주소 참조) ex) a=10
5.할당(Assignment) : 값을 변수에 저장하는 행위 ex) temp = 36.5
6.데이터 타입(Data Type) : 값의 종류(숫자,글자 등) ex)int,float,str
7.산술 연산자 : 수학적 계산에 사용되는 기호들 ex) +,-,*,/,//,%,**

오늘 공부한 내용 요약 및 정리
1.프로그래밍이란?
-컴퓨터가 이해할 수 있는 언어(프로그래밍 언어)를 사용해, 우리가 원하는 작업의 절차를 명령하는 과정입니다.
-파이썬(Python)은 문법이 간결하고 사람이 이해하기 쉬워 프로그래밍에 처음 입문하는 사람에게 가장 적합한 언어 중 하나입니다.

2.표현식,값,변수의 관계
-americano_price = 4500 라는 코드를 생각해 봅시다.
-컴퓨터는 오른쪽의 4500이라는 값(Value)을 먼저 확인합니다.
-그리고 = 기호를 통해 americano_price라는 변수(Variable)에 이 값을 할당(Assignment)합니다.
-이제 우리는 4500이라는 값 대신 americano_price라는 변수 이름으로 값을 편리하게 사용할 수 있습니다.


cd .. : 이전폴더
ls : 현재폴더에 있는 파일들알려줌
cd 폴더명/ : 그 폴더로이동





CLI
-CLI란?
컴퓨터와 대화하는 두 가지 방법
1) GUI (Graphic User Interface)
사진이 있는 메뉴판을 보고 손가락으로 주문하는 방식
장점: 쉽고 직관적
예시: 마우스를 아이콘으로 클릭하는 윈도우, macOS화면
2)CLI(Command Line Interface)
주방장에게 직접 말로 주문하는 방식
장점: 원하는 대로 정확하고, 세밀하며, 빠르게 요청할 수 있음
예시: 검은 화면에 명령어를 타이핑하여 소통하는 터미널 또는 명령 프롬프트(cmd)


GUI: 그래픽을 통해 사용자와 컴퓨터가 상호 작용하는 방식
CLI: 명령어를 통해 사용장와 컴퓨터가 상호 작용하는 방식


왜 CLI를 사용해야 할까?
-효율성: 키보드만으로 모든 작업을 빠르게 가볍게 수행할 수 있음
-정밀한 제어: 그래픽 화면에 보이지 않는 숨겨진 설정까지 정밀하게 제어할 수 있음
-강력한 자동화: 단순하고 반복적인 작업을 명령어 한 줄로 자동화할 수 있음
-표준 환경: 서버,클라우드 등 그래픽이 없는 개발 환경의 필수 도구



-문법 및 활용



-경로
CLI에서 가장 중요한 것: 내가 어디있는지(경로) 알아야 한다
-컴퓨터의 파일 시스템은 수많은 방으로 이루어진 거대한 '건물'과 같음
-경로는 이 건물 안에서 특정 방(디렉토리)이나 물건(파일)을 찾아가는 '주소'
-이 '주소'를 이해하는 것이 CLI의 첫걸음

경로의 핵심 개념(1/2)
-루트(root) 디렉토리(/): 건물의 '정문'또는 '1층로비'. 모든 주소의 시작점.
-홈 디렉토리(~): 나의 '집' 또는 '개인 사무실'. 터미널을 처음 켰을 때 시작하는 나의 기본 공간

경로의 핵심 개념(2/2)
-절대 경로 (Absolute Path)
정문(루트,root,/)부터 목적지까지의 전체 주소
누가 어디서 보든 항상 똑같은 주소
예시: /c/User/ssafy/
-상대경로(Realative Path)
'현재 내 위치'를 기준으로 한 주소
'저 방으로 가' (Desktop/) 또는 '이전 방으로 가'(..) 와 같음


-경로 실습

Git
-버전 관리 시스템
분산 버전 관리 시스템: 소스코드의 변경사항을 추적
중앙 vs 분산
위키피디아 vs GIT

-분산구조의 장점
중앙 서버에 의존하지 않고도 동시에 다양한 작업을 수행할 수 있음
중앙 서버의 장애나 손실에 대비하여 백업과 복구가 용이
인터넷에 연결되지 않은 환경에서도 작업을 계속할 수 있음(변경 이력과 코드를 로컬 저장소에 기록하고, 나중에 중앙서버와 동기화)



-Git의 영역
Working Directory: 실제 작업 중인 파일들이 위치하는 영역
Staging Area: Working Dirctory에서 변경된 파일 중 다음 버전에 포함시킬 파일들을 선택적으로 추가하거나 제외할 수 있는 중간준비영역
Repository: 버전 이력과 파일들이 영구적으로 저장되는 영역, 모든 버전과 변경 이력이 기록됨
*Git에서는 버전을 commit 이라고 부른다.

Commit: "버전"
변경된 파일들을 저장하는 행위이며, 마치 사진을 찍듯이 기록한다 하여 'snapshot'이라고도 함


-Git의 동작
git init
로컬 저장소 설정(초기화)


-Git 실습

로컬(local): 현재 사용자가 직접 접속하고 있는 기기 또는 시스템
git init 주의사항:
Git 로컬 저장소 내에 또다른 Git 로컬 저장소를 만들지 말 것(즉, 이미 Git 로컬 저장소인 디렉토리 내부 하단에서
git init 명령어를 다시 입력하지 말 것)
2.  Git 저장소 안에 Git 저장소가 있을 경우 가장 바깥 쪽의 Git 저장소가 안쪽의 Git 저장소의 변경사항을 추적할 수 없기 때문



처음에git init>수정, git add > (git status) > git commit -m "~~"
ctrl+~ : 터미널생성




리스트(list): 여러 개의 값을 순서대로 저장하는, 변경 가능한(mutable) 시퀀스 자료형 
my_list_1= [1, 'a' , 3, ['hello', '!!']] 대괄호 안에 뭐든지 가능

리스트의 시퀀스 특징 (문자열처럼 인덱싱,슬라이싱,길이확ㅇㅣㄴ, 반복 등 공통 기능을 모두 사용 가능)

문자열 시퀀스 한번확인

중첩(Nested) : 어떤 자료 구조 안에 같은 종류의자료 구조가 포함된 형태

중첩 리스트 접근하기 : print(my_list[4][-1])
print(my_list[-1][1][0]) 
-바깥쪽에서 안쪽으로 접근-

인덱싱으로 값 수정하기
my_list = [1,2,3,4,5]
my_list[1] = 'two'
print(my_list) # [1, 'two', 3, 4, 5]
-재할당이 아닌 수정-

슬라이싱으로 여러 값 한번에 바꾸기
my_list[2:4] = ['three', 'four']


튜플(tuple): 여러 개의 값을 순서대로 저장하는 변경 불가능한 시퀀스 자료형
my_tuple_1 = (1,) 단일요소 튜플을 만들 때는 반드시 후행쉼표(Trailing comma)를 사용해야 한다. 콤마를 안쓰면 괄호없는거취급.
my_tuple_2 = 1, 'hello', 3.14, True 소괄호없이 가능
튜플 역시 시퀀스이므로 인덱싱,슬라이싱,길이확인,반복 등 공통기능 모두 사용ㄱㅏ능
튜플의 불변성: 한번 생성된 튜플은 그 내용을 절대 수정,추가,삭제할 수 없음

my_tuple = (1, 'a', 3, 'b', 5)
my_tuple[1] = 'apple' << 불가능

튜플이 불변 자료형인 이유는 , 개발자가 아닌 내부 동작과 안전한 데이터 전달에 사용됨.(즉, 컴퓨터가 사용)


range: 연속된 정수 시퀀스를 생성하는, 변경 불가능한(immutable) 자료형
range 기본 구문: 
range()는 1개,2개, 또는 3개의 매개변수(인자)를 가질 수 있다.
range(start, stop, step)

range(stop)
ex) my_range_1 = range(5) 의 의미: range(5)는 0,1,2,3,4
print(my_range_1) # range(0,5) - range객체라 부르며 아직 0~4까지 만들어내진 못하고 덩어리로 둔상태. 아직 평가중(지연평가).
print(list(my_range_1) # [0,1,2,3,4]

range(start,stop)
ex) my_range_2 = range(1,10)
print(list(my_range_2)) # [1,2,3,4,5,6,7,8,9]

range(start, stop, step)

1.값의 범위 규칙
stop값은 포함하지 않는다
step 값은 간격과 방향을 결정
step이 음수일때: print(list(range(5,1,-1))) #[5,4,3,2]




dict(딕셔너리) : key-value 쌍으로 이루어진 순서와 중복이 없는(비시퀀스) 변경 가능한 자료형
즉, 인덱스가 없다. 즉 [1,1,2,2] 이런 중복안됨. 

my_dict_1 = {}
my_dict_2 = {'key' : 'value'}
my_dict_3 = {'apple' : 12, 'list' : [1,2,3]} -첫번째요소 그런거없음.
출력시 순서대로 출력되긴 하지만, 실제로 순서는 없음!
인덱스가 아닌 Key를 통한 접근만ㅇㅣ 가능

딕셔너리 규칙
Key의 규칙
***
-고유해야 함.
-변경 불가능한(immutable) 자료형만 사용 가능
가능: str, int, float, tuple
불가능: list, dict
***
Value의 규칙
-어떤 자료형이든 자유롭게 사용할 수 있음


딕셔너리 값 접근 방법
my_dict = {'name' : '홍길동', 'age' : 25}
print(my_dict['name']) = '홍길동'

딕셔너리 값 추가 및 변경
my_dict['name'] =  김세영 - 수정
my_dict['place'] = '부산'  - 추가
제거도 가능한데 이건 나중에

언제 딕셔너리를 사용할까요?
각 데이터에 의미있는 이름(Key)를 붙여 관리하고 싶으ㄹ때

API : 서버간의 통신에서 데이터를 다룰때 Key-Value형태의 데이터를 주고받음


my_dict['list'][0]



세트: 순서와 중복ㅇㅣ 없는 변경 가능한 자료형
세트 표현: 중괄호 {}
my_set_1 = set()
my_set_2 = {1,2,3}
my_set_3 = {1,1,1}
print(my_set_3)  # {1}

세트의 집합 연산
my_set_1 = {1,2,3}
my_set_2 = {3,6,9}

#합집합
print(my_set_1 | my_set_2)
#차집합
-
#교집합
&


None :  파이썬에서 '값이 없음'을 표현하는 특볋ㅏㄴ 데이터 타입
이것도 할당할 수 있는 엄연한 데이터타입. None 이라는 값이 메모리주소에 할당됨.


Bolean(불리언) : 참과거짓
비교/논리 연산의 평가결과로 사용됨.
조건/반복문과 함께 사용하ㄹ 예정~



Collection: 여러개의 값을 하나로 묶어 관리하는 자료형들을 통칭하는 말
str, list, tuple, range, set, dict

                변경가능여부    순서존재여부
str                     X                                  O                   시
list                   O                                  O                    퀀
tuple               X                                  O                     스
dict                  O                                 X
set                   O                                  X


불변과 가변
불변: str,tuple,range       : 변경불가,안전성,예측가능
가변: list, dict, set : 변경가능,유연성,효율성



리스트는 큰 메모리주소를 형성하고 그 안에 여러개의 메모리주소를 만든다.
그리고 큰 메모리주소 자체는 불변하지만, 여러개의 메모리주소에는 다른값을 할당할 수 있다.



형변환(Type Conversion) : 한 데이터타입을 다른 데이터타입으로 변환하는 과정
1.암시적 형변환: 파이써ㄴ이 자동으로 처리
2.명시적 형변환:ㅣ 개발자가 직접 지시

암시적형변환: 데이터손시릉ㄹ 막기위해 더 정밀한 타입으로 자동변환
print(3+5.0) # 8.0
print(True+3) #4
print(True+False) #1

명시적형변환: 
list("abc") #['a','b','c']

str>int : 안되는상황도잇음
int>str : 모두가능

되면되는거고 안되면안되는거다람쥐

복합 연산자: 연산과 할당을 함ㄲㅔ한다.
a += b 의 의미 a=a+b
근데 이거 쓰면 더 헷갈려서 걍 a=a+b 쓰면 될듯. 명시적관점에서 이게 더 좋다함.


비교연산자: 불리언값으로바ㄴ환
< , <=, ==, !=, is, is not

==연산자 vs is연산자
==연산자
값이 같은지를 비교

2.  is 연산자
객체 자체가 같은지를 비교(메모리 주소까지 비교)
print(2 is 2.0) #False
print(1 is True) #False

is연산자느ㄴ 언제쓰나요ㅗ
-주로 싱글턴 객체를 비교할때 비교
None,True,False 라는 이 세가지 값만큼은 고유한 메모리주소에 할당됨.
즉, None이라는 값이 두가지 메모리주소에 존재할 수 없음.

a = [1,2,3]
b = [1,2,3]

print[ a == b ] #True
print[ a is b ] #False

a의 주소를 b에 할당
b=a
print(a is b) #True

논리 연산자
print(True and False) # False
result = (num >10) and (age == 20)

단축평가
False and ?
에서 ?를몰라도 그냥 False이므로,,
앞에만 보고 평가

값이있으면 True임.
None,공백 등 이런건 False

iteam

단축평가예시묹 이해x



맴버십 연산자
in / in not 컬렉션
>> 불리언값으로 반환


ipynb

(0,1,2,3,4,5,6,7)










정리:
list : 대괄호, 변경가능
tuple: 소괄호, 변경불가
range: 함수, 소괄호 안 콤마연결
dict: 중괄호, Key:Value, 순서가없음






ctrl + shift + f


# 오늘의느낀점: 모르는건 메모해놓고 핵심에 집중하자. 머리가 너무아프다.